Порядок работы:
==============

1. сервер стартует логику, connections pool и гейты (надо бы сделать сначала инициализацию гейтов, а уже потом их автоматический старт)
2. гейты принимают соединение и создают инстанс соответствующего Connection (TcpConnection/WebsocketConnection)
3. принятое соединение отправляется в пул.
4. пул получает соединение и стартует чтение из соединения, подсовывая ему канал для сообщений. также пул подсовывает канал для уведомления о закрытии - в него пишет само соединение, уведомляя пул, что это соединение нужно удалить из списка
5. вычитанные соединением сообщения отправляются в канал для сообщений
6. логика принимает сообщение
7. ответные сообщения рассылаются всем клиентам

Для тестирования есть тулза: https://unity2go.googlecode.com/svn/trunk/library/NetTest

TcpGate
-------
* в данный момент tcp gate умеет вычитывать из соединения буфер по 1024 байта и отдаёт его как DataMessage. BaseMessage в данный момент инициализируется пустыми значениями.
* нужно сделать, чтобы сначала вычитывалась длина сообщения
* далее вычитывается массив байт равный вычитанной длине
* и вот уже вычитанный масси должен класться в сообщение (потом это будет protobuf строка)
* также непонятно, почему go говорит, что прочитал 22 байта на слово "привет" - по идее там только 12 байт. надо бы в тулзе для тестирования писать сколько байт занимает отправляемое сообщение.

WebSocketGate
-------------
* вычитывает обёртку из вебсокета
* парсит обёртку
* в зависимости от типа у обёртки парсит сообщение
* отдаёт сообщение в канал входящих сообщений
* логика обрабатывает сообщения
* логика посылает ответ в канал исходящих сообщений НАПРЯМУЮ (пишет в канал без вызова соответствующих методов), БЕЗ указания адресатов, ОБЫЧНОЕ текстовое сообщение (без обёртки ServerMessage)

Пул соединений
--------------
* принимает входящие подключения, ~~проверяет их~~, раздаёт id, сохраняет в списке подключений, запукает нормальное чтение
* получает исходящее сообщение от логики и рассылает через ВСЕ подключения (вроде как должен уже и по адресатам уметь рассылать)

Клиент
------
* подключается к серверу
* отправляет AuthMessage
* умеет отправлять текстовые сообщения
	
Не работает
-----------
* <s>Почему не получается использовать *Connection - ведь у нас это объекты и, по идее, нужно хранить ссылки на них</s>

	> Всё получается, если не путать понятие интерфейса и определения типа.
* <s>Не происходит окончания попытки записи в канал - канал сообщений, вроде бы, всё ещё существует. При попытке закрыть канал - вываливается ошибка, что мы закрываем уже закрытый канал</s>

	> Косяк был в том, что деструктор вызывался дважды. Вдобавок - пул не знал о закрытии соединения и всё-равно пытался в него отправлять сообщения

	
***Убраны все проверки с авторизацией. На данный момент клиент на старте присылает AuthMessage. Эта информация никуда не сохраняется, а просто выводится в лог.***

Что сделать
-----------
1. Решить как будут храниться события в логике? 

	> Есть предложение сделать eventQueue с двумя каналами - отправил, получил. тогда удобно будет делать select в главном цикле логики.
	
	> Можно сделать всё-таки хранилище прямо в логике, а select и так можно сделать через пакет time.

	> Для начала нужно сделать абстракцию и реализовать через массив, а уже потом озищряться со всем остальным.

2. <s>Логика должна знать кто к ней присоединился. Возможно, connections pool должен сам отправлять сообщение логики, что появился новый пользователь, а не от пользователя пересылать сообщение.</s>

	> именно так и сделано. Пул принимает авторизационное сообщение, создаёт нового пользователя и отправляет этого пользователя в логику.

3. <s>Приходящие сообщения тоже должны оборачиваться в обёртку, в которой есть указание от кого пришло сообщение</s>

	> исполнено

4. При закрытии канал сначала нужно отправлять уведомление в пул соединений, чтобы он вдруг не пытался писать в закрытый канал, а уже потом закрывать канал.

	> можно даже и в обратную сторону присылать уведомления - например, в канал исходящих сообщений, что мол всё, закругляйся.

5. Читатель блокируется на сокете. Писатель блокируется на пайпе. Как только читатель получает EOF - отправляет сообщение в пул и закрывает сокет. Если за это время писатель что-то получит и попробует записать - возникнет ошибка записи и не более того. Как только пул получит уведомление о закрытии - он закрывает пайп записи - в этот момент писатель просто выйдет (не важно - была до этого шибка или нет).

6. http://play.golang.org/p/AlQ9rOdXJU