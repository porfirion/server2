# Сервер


## Архитектура сервисов

Начитавшись [хабра](https://habrahabr.ru/company/mailru/blog/220359/) пришёл к выводу, что чат с игровой механикой не стоит держать в одном месте. Более того - это скорее даже мешает - всё валится в одну кучу. Также авторизация остаётся незакрытым вопросом. Пожалуй стоит оформить каждый из этих фрагментов как отдельный сервис.

Сейчас сервер - это набор сервисов, которые могут обмениваться друг с другом сообщениями через брокер. На данный момент есть следующие сервисы:
- пул соединений (принимает соединения через TCP и WS, парсит передаваемые данные и пробрасывает эти сообщения в брокер)
- авторизация
- чат
- игровая логика (должна ли быть отдельным сервером?)
- _статистика?_

Каждый сервис отправляет брокеру сообщения, а тот их отправляет куда следует. На данный момент предполагается следующее поведение:
- клиент подключается к пулу соединений и отправляет запрос на вторизацию
- пул пробрасывает запрос в сервис авторизации
- сервис авторизации пока ничего не проверяет - он **создаёт нового пользователя в системе и делает 2 вещи**: 
    - отправляет **ответ обратно в пул соединений**, чтобы можно было что-то ответить пользователю
    - отправляет **уведомление в игровую логику** о присоединении нового игрока
- соответственно логика, как только получает уведомление - добавляет этого пользователя в список, создаёт под него новый объект и отправляет пользователю "welcome!"

## Брокер
~~Надо приделать ему поддержку fiber или как его там - добавлять в service message requestId и отдавать ответ на это сообщение с таким же requestId~~ (а может и не надо.. по идее на данный момент логика задумывается совсем простая и никаких запросов клиент присылать не будет).

## Логика

Симуляция производится строго по шагам с фиксированным периодом. В идеале стараемся, чтобы шаги симуляции совпадали с реальынм временем. Все приходящие от пользователей сообщения клаёдм в массив с метками времени, в которое они пришли. Этот массив потом должен позволить "воспроизвести" симуляцию. Надо бы приделать сохранение всего стейта симуляции, чтобы потом его можно было загрузить и применить пользовательский ввод и проверить, что всё точно считается. 

## Пул соединений

Пользователь в системе может существовать в разных контекстах. Пул соединений нумерует по порядку всех пользователей и сообщения им отправляются именно по этим id. У авторизации пользователи должны быть свои, но с привязкой к id пула.
У логики пользователи тоже свои, но с привязкой к id пула и ссылкой на пользователя в авторизации. По идее это всё должны быть прямо разные структуры данных, чтобы избежать concurrent modification в случае чего

## Авторизация




## Заметки

[Проблема с рефлексией](http://play.golang.org/p/AlQ9rOdXJU)
    > Объяснил добрый дядя на stackoverflow
  
Instead of sending throw broker we can pass client description with it's connection 
straight into logic - less overhead for sending.
Users should be registered globally in the server with all info (including connection). 
Each service can send info independently (chat doesn't collide with logic).
  

    MAIN STEP
        get inputs from queue and apply to world objects
        simulate N times
            wide phase
                foreach activeObject - find possible collisions (AABB)
            foreach possiblyCollidingObject
                check collision
            before collision
            resolve collisions
            after collision?
            update state
            should we remember objects in viewport in that place? (possibly less checks for distance)
    
        foreach player: 
            find objects in viewport (static objects are easy to find - in quadtree, what to do with active objects?)
            count new state
            count diff
            send diff (or full state if old)
    
    
    Logic main loop 
        wait for inputs from players
            put them into queue
        wait for simulation time
            MAIN STEP
    
    
    sending info to client
        add to send buffer
        send averything from buffer
        on received acknowledge - remove from buffer
        on diff lifetime expire - remove old from buffer
        
----------------------------------
<pre>
основной цикл
	если
		пошаговая симуляция
			принимаем все инпуты, какие есть до тех пор, пока нам не пришлют указаний действовать
			делаем шаг симуляции и применяем все инпуты из очереди
		повтор
			ничего не принимаем
			делаем шаг симуляции, беря все инпуты, которые пришли к этому моменту
		обычный режим
			до тех пор, пока не настало время делать шаг симуляции - принимаем инпуты
			делаем шаг симуляции, применяя все инпуты, которые успели придти. Предполагаем, что всё остальное - просто не успело придти. Если приходит больше, чем мы успеваем положить в очередь за один шаг - значит нас спамят и проблему нужно решать отдельно. Но всё, что успело придти - должно быть обработано.

ОБЩИЙ СЛУЧАЙ ЦИКЛА
	ПОЛУЧАЕМ ИНПУТЫ -> очередь инпутов
		пошаговая симуляция - принимаем инпуты пока не скажут симулировать
		повтоп - просто берём все инпуты до следующего шага
		обычный режим - принимаем пока не настанет время симуляции
	ШАГ СИМУЛЯЦИИ <- очередь инпутов (вот тут должна происходить запись инпутов, чтобы потом можно было увидеть откаты и т.п.)


ШАГ СИМУЛЯЦИИ
	берём из очереди все принятые инпуты по времени предполагаемой отправки (корректировать время отправки не более N msec).
		если есть инпуты, которые совсем древние и должны были быть обсчитаны раньше, 
			то
				откатываем состояние мира до самого древнего инпута
				раскладываем старые инпуты в более старые очереди инпутов
				получаем актуальный 
					стейт + [tickN-2_inputs, tickN-1_inputs,  tickN_inputs]
			иначе
			    просто складываем их в один массив
				текущий стейт + [tickN_inputs]
	inputsArr.forEach(inputs -> {
		state = simulate(state, inputs);
		state.tick++;
	})
	рассылаем всем уведомления об изменении


simulate(state, inputs)
	применяем все эти инпуты (изменяем вектора приложения сил/движения, создаём/удаляем объекты)
	рассчитываем состояние мира
		ищем потенциальные коллизии
		проверяем потенциальные коллизии 
			если пересекаются
				before collision
				collision
					или добавляем объектам дополнительные вектора (силы) - отталкивание/притяжение
					или уничтожаем объекты
					или смещаем объекты?
				after collision?
		перебираем все активные объекты и суммируем их вектора
		перемещаем каждый объект на результирующий вектор


Очередь событий можно вешать:
1) на сами объекты. и держать ссылки на объекты, у которых есть что-то в очереди. Тогда на каждом шаге проверяем все объекты - не произошло ли что-то из этих событий. Очень просто отменять события для конкретных объектов
2) на секунды. Тогда при отмене события для какого-то объекта придётся перебирать все последующие секунды и проверять нет ли событий для данного объекта на данную секунду.
3) и на объекты, и на секунды. А отмену производить не удалением, а простановкой флага cancelled. Тогда на каждую секунду мы заранее знаем список событий и просто не будем учитывать отменённые, а для каждого объекта события также известны и их легко будет отменить.

Как делать отмену событий, если стейт может откатиться? По идее очередь событий должна лежать в гейм стейте (а он должен быть иммутабельным по дефолту).
Как делать копирование геймстейта? Сделать его структурой без ссылок я не знаю как - массивы под объекты и игроков либо будут динамической длины, либо уж очень большими. Видимо, придётся руками отдельно поля копировать и сохранять их где-то...
<pre>